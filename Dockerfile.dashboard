# Development Dashboard Container
# Real-time monitoring for Rust tools and Python development

FROM node:18-alpine as frontend-builder

# Install build dependencies
RUN apk add --no-cache git python3 make g++

WORKDIR /app/frontend

# Copy package files
COPY dashboard/frontend/package*.json ./
RUN npm ci --only=production

# Copy source code
COPY dashboard/frontend/ ./

# Build frontend
RUN npm run build

# ========================
# Python Backend Stage
# ========================
FROM python:3.11-slim

# Install system dependencies
RUN apt-get update && apt-get install -y \
    curl \
    wget \
    git \
    ca-certificates \
    && rm -rf /var/lib/apt/lists/*

# Create non-root user
RUN groupadd -r dashboard && useradd -r -g dashboard -d /app -s /bin/bash dashboard

# Install Python dependencies
RUN pip install --no-cache-dir \
    fastapi \
    uvicorn \
    websockets \
    aiohttp \
    aiofiles \
    psutil \
    prometheus-client \
    pydantic \
    python-multipart

WORKDIR /app

# Copy frontend build
COPY --from=frontend-builder /app/frontend/dist ./static

# Create dashboard backend
RUN cat > /app/dashboard_server.py << 'EOF'
#!/usr/bin/env python3
"""
Real-time Development Dashboard
Monitors Rust filewatcher, LSP server, and Python development metrics
"""

import asyncio
import json
import logging
import os
import time
from typing import Dict, List, Any, Optional
import aiohttp
import websockets
from fastapi import FastAPI, WebSocket, HTTPException
from fastapi.staticfiles import StaticFiles
from fastapi.responses import HTMLResponse, JSONResponse
import uvicorn
import psutil

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('/logs/dashboard.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

app = FastAPI(title="GTerminal Development Dashboard", version="1.0.0")

# Mount static files
app.mount("/static", StaticFiles(directory="/app/static"), name="static")

class DashboardMetrics:
    def __init__(self):
        self.start_time = time.time()
        self.connected_clients = 0
        self.total_events = 0
        self.service_status = {}

    def to_dict(self) -> Dict[str, Any]:
        return {
            "uptime_seconds": int(time.time() - self.start_time),
            "connected_clients": self.connected_clients,
            "total_events": self.total_events,
            "service_status": self.service_status
        }

metrics = DashboardMetrics()

# Service endpoints
SERVICES = {
    "filewatcher": {
        "url": os.getenv("FILEWATCHER_METRICS_URL", "http://rust-filewatcher:8766"),
        "health_endpoint": "/health",
        "metrics_endpoint": "/metrics"
    },
    "lsp_server": {
        "url": os.getenv("LSP_SERVER_URL", "http://ruff-lsp:8767"),
        "health_endpoint": "/health",
        "metrics_endpoint": "/metrics"
    },
    "gterminal": {
        "url": os.getenv("GTERMINAL_URL", "http://gterminal-app:8000"),
        "health_endpoint": "/health",
        "metrics_endpoint": "/metrics"
    },
    "prometheus": {
        "url": os.getenv("PROMETHEUS_URL", "http://prometheus:9090"),
        "health_endpoint": "/-/healthy",
        "metrics_endpoint": "/api/v1/query?query=up"
    }
}

async def check_service_health(service_name: str, config: Dict) -> Dict[str, Any]:
    """Check health of a service"""
    try:
        timeout = aiohttp.ClientTimeout(total=5)
        async with aiohttp.ClientSession(timeout=timeout) as session:
            health_url = f"{config['url']}{config['health_endpoint']}"
            async with session.get(health_url) as response:
                if response.status == 200:
                    return {
                        "status": "healthy",
                        "response_time_ms": 0,  # Would need timing
                        "last_check": int(time.time())
                    }
                else:
                    return {
                        "status": "unhealthy",
                        "error": f"HTTP {response.status}",
                        "last_check": int(time.time())
                    }
    except Exception as e:
        return {
            "status": "error",
            "error": str(e),
            "last_check": int(time.time())
        }

async def get_service_metrics(service_name: str, config: Dict) -> Dict[str, Any]:
    """Get metrics from a service"""
    try:
        timeout = aiohttp.ClientTimeout(total=5)
        async with aiohttp.ClientSession(timeout=timeout) as session:
            metrics_url = f"{config['url']}{config['metrics_endpoint']}"
            async with session.get(metrics_url) as response:
                if response.status == 200:
                    return await response.json()
                else:
                    return {"error": f"HTTP {response.status}"}
    except Exception as e:
        return {"error": str(e)}

@app.get("/")
async def dashboard_home():
    """Serve dashboard home page"""
    html_content = """
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GTerminal Development Dashboard</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background: #1e1e1e;
            color: #ffffff;
            margin: 0;
            padding: 20px;
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
            border-bottom: 2px solid #333;
            padding-bottom: 15px;
        }
        .services {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        .service-card {
            background: #2d2d30;
            border-radius: 8px;
            padding: 20px;
            border-left: 4px solid #007acc;
        }
        .service-card.healthy { border-left-color: #28a745; }
        .service-card.unhealthy { border-left-color: #dc3545; }
        .service-card.error { border-left-color: #ffc107; }
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .status-healthy { background-color: #28a745; }
        .status-unhealthy { background-color: #dc3545; }
        .status-error { background-color: #ffc107; }
        .metrics {
            background: #2d2d30;
            border-radius: 8px;
            padding: 20px;
        }
        .metric-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        .log-viewer {
            background: #1e1e1e;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 15px;
            height: 300px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üöÄ GTerminal Development Dashboard</h1>
        <p>Real-time monitoring for Rust tools and Python development</p>
    </div>

    <div id="services" class="services">
        <!-- Services will be populated by JavaScript -->
    </div>

    <div class="metrics">
        <h2>üìä System Metrics</h2>
        <div id="system-metrics">
            <!-- System metrics will be populated -->
        </div>
    </div>

    <div class="metrics">
        <h2>üìù Live Logs</h2>
        <div id="logs" class="log-viewer">
            Connecting to log stream...
        </div>
    </div>

    <script>
        const wsUrl = `ws://${window.location.host}/ws`;
        const ws = new WebSocket(wsUrl);

        ws.onopen = function() {
            console.log('WebSocket connected');
            addLog('üì° Dashboard connected');
        };

        ws.onmessage = function(event) {
            const data = JSON.parse(event.data);
            if (data.type === 'services_update') {
                updateServices(data.services);
            } else if (data.type === 'metrics_update') {
                updateMetrics(data.metrics);
            } else if (data.type === 'log_entry') {
                addLog(data.message);
            }
        };

        function updateServices(services) {
            const container = document.getElementById('services');
            container.innerHTML = '';

            Object.entries(services).forEach(([name, status]) => {
                const card = document.createElement('div');
                card.className = `service-card ${status.status}`;
                card.innerHTML = `
                    <h3>
                        <span class="status-indicator status-${status.status}"></span>
                        ${name.toUpperCase()}
                    </h3>
                    <p><strong>Status:</strong> ${status.status}</p>
                    ${status.error ? `<p><strong>Error:</strong> ${status.error}</p>` : ''}
                    <p><strong>Last Check:</strong> ${new Date(status.last_check * 1000).toLocaleTimeString()}</p>
                `;
                container.appendChild(card);
            });
        }

        function updateMetrics(metrics) {
            const container = document.getElementById('system-metrics');
            container.innerHTML = `
                <div class="metric-row">
                    <span>Uptime:</span>
                    <span>${Math.floor(metrics.uptime_seconds / 60)} minutes</span>
                </div>
                <div class="metric-row">
                    <span>Connected Clients:</span>
                    <span>${metrics.connected_clients}</span>
                </div>
                <div class="metric-row">
                    <span>Total Events:</span>
                    <span>${metrics.total_events}</span>
                </div>
            `;
        }

        function addLog(message) {
            const logs = document.getElementById('logs');
            const time = new Date().toLocaleTimeString();
            logs.innerHTML += `[${time}] ${message}<br>`;
            logs.scrollTop = logs.scrollHeight;
        }

        // Request initial data
        setInterval(() => {
            if (ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({type: 'request_update'}));
            }
        }, 5000);
    </script>
</body>
</html>
    """
    return HTMLResponse(content=html_content)

@app.get("/health")
async def health_check():
    """Health check endpoint"""
    return {
        "status": "healthy",
        "service": "development-dashboard",
        "uptime": int(time.time() - metrics.start_time)
    }

@app.get("/api/services")
async def get_services_status():
    """Get status of all monitored services"""
    service_status = {}

    for service_name, config in SERVICES.items():
        service_status[service_name] = await check_service_health(service_name, config)

    return service_status

@app.get("/api/metrics/{service_name}")
async def get_service_metrics_endpoint(service_name: str):
    """Get metrics for a specific service"""
    if service_name not in SERVICES:
        raise HTTPException(status_code=404, detail="Service not found")

    return await get_service_metrics(service_name, SERVICES[service_name])

@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    """WebSocket endpoint for real-time updates"""
    await websocket.accept()
    metrics.connected_clients += 1
    logger.info(f"WebSocket client connected (total: {metrics.connected_clients})")

    try:
        while True:
            try:
                # Wait for client message or timeout
                message = await asyncio.wait_for(
                    websocket.receive_text(),
                    timeout=30.0
                )

                data = json.loads(message)

                if data.get('type') == 'request_update':
                    # Send services status
                    service_status = await get_services_status()
                    await websocket.send_text(json.dumps({
                        "type": "services_update",
                        "services": service_status
                    }))

                    # Send metrics
                    await websocket.send_text(json.dumps({
                        "type": "metrics_update",
                        "metrics": metrics.to_dict()
                    }))

                    metrics.total_events += 1

            except asyncio.TimeoutError:
                # Send periodic updates
                service_status = await get_services_status()
                await websocket.send_text(json.dumps({
                    "type": "services_update",
                    "services": service_status
                }))

    except Exception as e:
        logger.error(f"WebSocket error: {e}")
    finally:
        metrics.connected_clients -= 1
        logger.info(f"WebSocket client disconnected (remaining: {metrics.connected_clients})")

if __name__ == "__main__":
    port = int(os.getenv("DASHBOARD_PORT", 8080))
    host = os.getenv("DASHBOARD_HOST", "0.0.0.0")

    logger.info(f"Starting Development Dashboard on {host}:{port}")

    uvicorn.run(
        app,
        host=host,
        port=port,
        log_level="info"
    )
EOF

# Make dashboard server executable
RUN chmod +x /app/dashboard_server.py

# Create directories and set permissions
RUN mkdir -p /data /logs /config \
    && chown -R dashboard:dashboard /app /data /logs /config

# Switch to non-root user
USER dashboard

# Expose ports
EXPOSE 8080 8081

# Health check
HEALTHCHECK --interval=30s --timeout=5s --start-period=15s --retries=3 \
    CMD curl -f http://localhost:8080/health || exit 1

# Start the dashboard
CMD ["python", "/app/dashboard_server.py"]
